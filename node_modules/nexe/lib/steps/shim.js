"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function wrap(code) {
    return '!(function () {' + code + '})();';
}
function default_1(compiler, next) {
    compiler.shims.push(wrap(compiler.getHeader()));
    if (compiler.options.resources.length) {
        compiler.shims.push(wrap("\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar assert_1 = require(\"assert\");\r\nvar path_1 = require(\"path\");\r\nvar binary = process.__nexe;\r\nassert_1.ok(binary);\r\nvar manifest = binary.resources;\r\nvar isString = function (x) { return typeof x === 'string' || x instanceof String; };\r\nif (Object.keys(manifest).length) {\r\n    var fs_1 = require('fs');\r\n    var originalReadFile_1 = fs_1.readFile;\r\n    var originalReadFileSync_1 = fs_1.readFileSync;\r\n    var resourceStart_1 = binary.layout.resourceStart;\r\n    var setupManifest_1 = function () {\r\n        var manifest = binary.resources;\r\n        Object.keys(manifest).forEach(function (key) {\r\n            var absolutePath = path_1.resolve(key);\r\n            if (!manifest[absolutePath]) {\r\n                manifest[absolutePath] = manifest[key];\r\n            }\r\n            var normalizedPath = path_1.normalize(key);\r\n            if (!manifest[normalizedPath]) {\r\n                manifest[normalizedPath] = manifest[key];\r\n            }\r\n        });\r\n        setupManifest_1 = function () { };\r\n    };\r\n    //TODO track inflight fs reqs??\r\n    var nfs = {\r\n        readFile: function readFile(file, options, callback) {\r\n            setupManifest_1();\r\n            var entry = manifest[file];\r\n            if (!entry || !isString(file)) {\r\n                return originalReadFile_1.apply(fs_1, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart_1 + offset;\r\n            var encoding = isString(options) ? options : null;\r\n            callback = typeof options === 'function' ? options : callback;\r\n            fs_1.open(process.execPath, 'r', function (err, fd) {\r\n                if (err)\r\n                    return callback(err, null);\r\n                fs_1.read(fd, Buffer.alloc(length), 0, length, resourceOffset, function (error, bytesRead, result) {\r\n                    if (error) {\r\n                        return fs_1.close(fd, function () {\r\n                            callback(error, null);\r\n                        });\r\n                    }\r\n                    fs_1.close(fd, function (err) {\r\n                        if (err) {\r\n                            return callback(err, result);\r\n                        }\r\n                        callback(err, encoding ? result.toString(encoding) : result);\r\n                    });\r\n                });\r\n            });\r\n        },\r\n        readFileSync: function readFileSync(file, options) {\r\n            setupManifest_1();\r\n            var entry = manifest[file];\r\n            if (!entry || !isString(file)) {\r\n                return originalReadFileSync_1.apply(fs_1, arguments);\r\n            }\r\n            var offset = entry[0], length = entry[1];\r\n            var resourceOffset = resourceStart_1 + offset;\r\n            var encoding = isString(options) ? options : null;\r\n            var fd = fs_1.openSync(process.execPath, 'r');\r\n            var result = Buffer.alloc(length);\r\n            fs_1.readSync(fd, result, 0, length, resourceOffset);\r\n            fs_1.closeSync(fd);\r\n            return encoding ? result.toString(encoding) : result;\r\n        }\r\n    };\r\n    Object.assign(fs_1, nfs);\r\n}\r\n"));
    }
    if (compiler.options.fakeArgv) {
        var nty = !process.stdin.isTTY;
        var input = nty ? '[stdin]' : compiler.options.input;
        compiler.shims.push(wrap("\n      var r = require('path').resolve; \n      process.argv.splice(1,0, " + (nty ? "'" + input + "'" : "r(\"" + input + "\")") + ");"));
    }
    return next();
}
exports.default = default_1;
