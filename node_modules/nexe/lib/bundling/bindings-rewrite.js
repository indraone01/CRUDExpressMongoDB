"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var child = require("child_process");
var crypto_1 = require("crypto");
function hashName(name) {
    return crypto_1.createHash('md5')
        .update(name)
        .digest('hex')
        .toString()
        .slice(0, 8);
}
function embedDotNode(options, file) {
    var contents = fs.readFileSync(file.absPath);
    var modulePathParts = file.absPath.split(path.sep).reverse();
    var module = modulePathParts[modulePathParts.findIndex(function (x) { return x === 'node_modules'; }) - 1];
    var bindingName = path.basename(file.absPath);
    var settings = options[module];
    var moduleDir = hashName(contents);
    file.contents = "\n  var fs=require('fs');var path=require('path');var binding='" + contents.toString('base64') + "';function mkdirp(r,t){t=t||null,r=path.resolve(r);try{fs.mkdirSync(r),t=t||r}catch(c){if(\"ENOENT\"===c.code)t=mkdirp(path.dirname(r),t),mkdirp(r,t);else{var i;try{i=fs.statSync(r)}catch(r){throw c}if(!i.isDirectory())throw c}}return t};";
    if (!settings || settings === true) {
        file.contents += ("\n      mkdirp('" + moduleDir + "');\n      var bindingPath = path.join(process.cwd(), '" + moduleDir + "', '" + bindingName + "')\n      require('fs').writeFileSync(bindingPath, Buffer.from(binding, 'base64'))\n      process.dlopen(module, bindingPath)\n    ").trim();
        return;
    }
    var depth = 0;
    settings.additionalFiles.forEach(function (file) {
        var ownDepth = 0;
        file.split('/').forEach(function (x) { return x === '..' && ownDepth++; });
        depth = ownDepth > depth ? ownDepth : depth;
    });
    var segments = [moduleDir];
    while (depth--) {
        segments.push(hashName(moduleDir + depth));
    }
    segments.push(bindingName);
    file.contents += "\n    var cwd = process.cwd()\n    var bindingFileParts = " + JSON.stringify(segments) + ";\n    var bindingFile = path.join.apply(path, [cwd].concat(bindingFileParts));\n    mkdirp(path.dirname(bindingFile));\n    fs.writeFileSync(bindingFile, Buffer.from(binding, 'base64'));\n    " + settings.additionalFiles.reduce(function (code, filename, i) {
        var contents = fs.readFileSync(path.join(path.dirname(file.absPath), filename));
        return (code += "\n        var file" + i + " = '" + contents.toString('base64') + "';\n        var filePath" + i + " = path.join(cwd, bindingFileParts[0], '" + filename.split('../').join('') + "');\n        mkdirp(path.dirname(filePath" + i + "));\n        fs.writeFileSync(filePath" + i + ", Buffer.from(file" + i + ", 'base64'));\n      ");
    }, '') + ";\n    process.dlopen(module, bindingFile)\n  ";
}
exports.embedDotNode = embedDotNode;
function findNativeModulePath(filePath, bindingsArg) {
    var dirname = path.dirname(filePath);
    var tempFile = Math.random() * 100 + '.js';
    var tempFilePath = path.join(dirname, tempFile);
    fs.writeFileSync(tempFilePath, "\n    var bindings = require('bindings');\n    var Module = require('module');\n    var originalRequire = Module.prototype.require;\n    Module.prototype.require = function(path) {\n      const mod = originalRequire.apply(this, arguments);\n      process.stdout.write(path)\n      return mod\n    };\n    bindings('" + bindingsArg + "')\n  ");
    //using exec because it can be done sync
    var nativeFileName = child.execSync('node ' + tempFile, { cwd: dirname }).toString();
    fs.unlinkSync(tempFilePath);
    var relativePath = './' + path.relative(dirname, nativeFileName).replace(/\\/g, '/');
    return relativePath;
}
/**
 * Traverse all nodes in a file and evaluate usages of the bindings module
 * handles two common cases
 */
var BindingsRewrite = /** @class */ (function () {
    function BindingsRewrite() {
        this.bindingsIdNodes = [];
        this.nativeModulePaths = [];
        this.rewrite = false;
    }
    BindingsRewrite.prototype.isRequire = function (node, moduleName) {
        return node.callee.name === 'require' && node.arguments[0].value === moduleName;
    };
    BindingsRewrite.prototype.onNode = function (absolutePath, node, parent) {
        if (node.type === 'CallExpression') {
            if (this.isRequire(node, 'bindings') && parent.type === 'VariableDeclarator') {
                /**
                 * const loadBindings = require('bindings');
                 *   -> const loadBindings = String('');
                 */
                this.bindingsIdNodes.push(parent.id);
                node.callee.name = 'String';
                node.arguments[0].value = '';
                this.rewrite = true;
                return;
            }
            if (this.isRequire(node, 'bindings') && parent.type === 'CallExpression') {
                /**
                 *const bindings = require('bindings')('native-module')....
                 *  -> const bindings = require('./path/to/native/module.node').....
                 */
                var bindingsArgNode = parent.arguments[0];
                if (bindingsArgNode.type === 'Literal') {
                    parent.callee = { type: 'Identifier', name: 'require' };
                    bindingsArgNode.value = findNativeModulePath(absolutePath, bindingsArgNode.value);
                    this.nativeModulePaths.push(bindingsArgNode.value);
                    this.rewrite = true;
                    return;
                }
            }
            var bindingsInvocationIdx = this.bindingsIdNodes.findIndex(function (x) { return node.callee.name === x.name; });
            if (this.bindingsIdNodes[bindingsInvocationIdx]) {
                /**
                 * const bindings = loadBindings('native-module')
                 *   -> const bindings = require('./path/to/native/module.node')
                 */
                var bindingsIdNode = this.bindingsIdNodes[bindingsInvocationIdx];
                var bindingsArgNode = node.arguments[0];
                this.bindingsIdNodes.splice(bindingsInvocationIdx, 1);
                if (bindingsArgNode.type === 'Literal') {
                    node.callee.name = 'require';
                    bindingsArgNode.value = findNativeModulePath(absolutePath, bindingsArgNode.value);
                    this.nativeModulePaths.push(bindingsArgNode.value);
                    this.rewrite = true;
                    return;
                }
            }
        }
    };
    return BindingsRewrite;
}());
exports.BindingsRewrite = BindingsRewrite;
