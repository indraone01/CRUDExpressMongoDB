"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var parseArgv = require("minimist");
var util_1 = require("./util");
var path_1 = require("path");
var target_1 = require("./target");
var os_1 = require("os");
var c = require("chalk");
exports.version = "2.0.0-rc.11";
var defaults = {
    flags: [],
    cwd: process.cwd(),
    configure: [],
    make: [],
    targets: [],
    vcBuild: util_1.isWindows ? ['nosign', 'release'] : [],
    enableNodeCli: false,
    compress: false,
    build: false,
    bundle: true,
    patches: [],
    plugins: []
};
var alias = {
    i: 'input',
    o: 'output',
    v: 'version',
    t: 'target',
    b: 'build',
    n: 'name',
    r: 'resource',
    a: 'resource',
    p: 'python',
    f: 'flag',
    c: 'configure',
    m: 'make',
    h: 'help',
    l: 'loglevel',
    'fake-argv': 'fakeArgv'
};
var argv = parseArgv(process.argv, { alias: alias, default: __assign({}, defaults, { enableStdIn: true }) });
exports.argv = argv;
var g = c.gray;
var help = ("\n" + c.bold('nexe <entry-file> [options]') + "\n\n   " + c.underline.bold('Options:') + "\n\n  -i   --input                      -- application entry point\n  -o   --output                     -- path to output file\n  -t   --target                     -- node version description\n  -n   --name                       -- main app module name\n  -r   --resource                   -- *embed files (glob) within the binary\n       --plugin                     -- extend nexe runtime behavior\n\n   " + c.underline.bold('Building from source:') + "\n\n  -b   --build                      -- build from source\n  -p   --python                     -- python2 (as python) executable path\n  -f   --flag                       -- *v8 flags to include during compilation\n  -c   --configure                  -- *arguments to the configure step\n  -m   --make                       -- *arguments to the make/build step\n       --snapshot                   -- path to a warmup snapshot\n       --ico                        -- file name for alternate icon file (windows)\n       --rc-*                       -- populate rc file options (windows)\n       --sourceUrl                  -- pass an alternate source (node.tar.gz) url\n       --enableNodeCli              -- enable node cli enforcement (blocks app cli)\n\n   " + c.underline.bold('Other options:') + "\n\n       --bundle                     -- custom bundling module with 'createBundle' export\n       --temp                       -- temp file storage default './nexe'\n       --cwd                        -- set the current working directory for the command\n       --fake-argv                  -- fake argv[1] with entry file\n       --clean                      -- force download of sources\n       --silent                     -- disable logging\n       --verbose                    -- set logging to verbose\n\n       -* variable key name         * option can be used more than once").trim();
exports.help = help;
exports.help = help = os_1.EOL + help + os_1.EOL;
function flatten() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return (_a = []).concat.apply(_a, args).filter(function (x) { return x; });
    var _a;
}
/**
 * Extract keys such as { "rc-CompanyName": "Node.js" } to
 * { CompanyName: "Node.js" }
 * @param {*} match
 * @param {*} options
 */
function extractCliMap(match, options) {
    return Object.keys(options)
        .filter(function (x) { return match.test(x); })
        .reduce(function (map, option) {
        var key = option.split('-')[1];
        map[key] = options[option];
        delete options[option];
        return map;
    }, {});
}
function tryResolveMainFileName(cwd) {
    var filename;
    try {
        var file = require.resolve(cwd);
        filename = path_1.basename(file).replace(path_1.extname(file), '');
    }
    catch (_) { }
    return filename ? filename : 'nexe_' + Date.now();
}
function extractLogLevel(options) {
    if (options.loglevel)
        return options.loglevel;
    if (options.silent)
        return 'silent';
    if (options.verbose)
        return 'verbose';
    return 'info';
}
function isName(name) {
    return name && name !== 'index';
}
function extractName(options) {
    var name = options.name;
    if (!isName(name) && typeof options.input === 'string') {
        name = path_1.basename(options.input).replace(path_1.extname(options.input), '');
    }
    if (!isName(name)) {
        name = tryResolveMainFileName(options.cwd);
    }
    if (!isName(name) && path_1.basename(options.cwd)) {
        name = path_1.basename(options.cwd);
    }
    return name.replace(/\.exe$/, '');
}
function isEntryFile(filename) {
    return filename && !path_1.isAbsolute(filename) && filename !== 'node' && /\.(tsx?|jsx?)$/.test(filename);
}
function findInput(input, cwd) {
    var maybeInput = argv._.slice().pop() || '';
    if (input) {
        return input;
    }
    if (isEntryFile(maybeInput)) {
        return maybeInput;
    }
    if (!process.stdin.isTTY) {
        return '';
    }
    try {
        var main = require.resolve(cwd);
        return './' + path_1.relative(cwd, main);
    }
    catch (e) {
        void e;
    }
    return '';
}
function normalizeOptionsAsync(input) {
    var options = Object.assign({}, defaults, input);
    var opts = options;
    options.temp = options.temp || process.env.NEXE_TEMP || path_1.join(options.cwd, '.nexe');
    options.input = findInput(options.input, options.cwd);
    options.name = extractName(options);
    options.loglevel = extractLogLevel(options);
    options.flags = flatten(opts.flag, options.flags);
    options.targets = flatten(opts.target, options.targets).map(target_1.getTarget);
    options.make = flatten(options.vcBuild, options.make);
    options.configure = flatten(options.configure);
    options.resources = flatten(opts.resource, options.resources);
    options.rc = options.rc || extractCliMap(/^rc-.*/, options);
    if (!options.targets.length) {
        options.targets.push(target_1.getTarget());
    }
    if (options.build) {
        var arch = options.targets[0].arch;
        if (util_1.isWindows) {
            options.make = Array.from(new Set(options.make.concat(arch)));
        }
        else {
            options.configure = Array.from(new Set(options.configure.concat(["--dest-cpu=" + arch])));
        }
    }
    var requireDefault = function (x) {
        if (typeof x === 'string') {
            return require(x).default;
        }
        return x;
    };
    options.plugins = options.plugins.map(requireDefault);
    options.patches = options.patches.map(requireDefault);
    Object.keys(alias)
        .filter(function (k) { return k !== 'rc'; })
        .forEach(function (x) { return delete opts[x]; });
    return Promise.resolve(options);
}
exports.normalizeOptionsAsync = normalizeOptionsAsync;
